#+HTML_HEAD: <!-- -*- fill-column: 87 -*- -->
#+HTML_HEAD: <!-- org-toggle-inline-images -->

#+TITLE: Virtlevel
#+INFOJS_OPT: view:overview toc:nil

#+TAGS: { pyub ranma rigidus unrimah noa}

#+NAME:css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="/css/css.css" />
#+END_HTML

Архитектура системы, уровни алгоритмов работы с оборудованием

* Описание и цели

  Этот файл описывает интерфейсы нижнего архитектурного уровня =HardwarePresentationLayer=,
  предназначенного для представления оборудования в виде абстракции для следующих
  архитектурных уровней.
  Этот архитектурный уровень выполняет функцию преобразования представления
  данных от различных вариантов подключенного конкретного оборудования в единообразное
  представление абстрактного оборудования для =BusinessLogicLayer= и наоборот.

  Цели:
  - предоставить уровню бизнес-логики =BusinessLogicLayer=
    единообразный интерфейс работы с любым набором оборудования
  - взять на себя работу с параметрами конкретного подключенного
    оборудования.

* Уровни и компоненты архитектуры
** Глоссарий

   =BusinessLogic= - всё, что связано с логикой работы системы

   =Hardware= - всё, что связано с оборудованием

   =Software= - всё, что связано с исполняемым ПО

   =UI= (user interface) - всё, что связано с интерфейсом пользователя

   =Presentation= - представление конкретного оборудования в памяти в виде структур
   данных и событий.

   =Component= - функциональный блок в составе архитектуры проекта, описывающий решение
   отдельной задачи.

** Слой =BusinessLogicLayer=

   =BusinessLogicLayer= - это слой описания конкретных процессов для абстрактного
   функционального оборудования.

   [TODO: rigidus] Опиши по возможности, на какие компоненты может быть поделен
   =BusinessLogicLayer= такое разделение поможет шарить работу по возможности.
   например.

   [note:rigidus] Невозможно сказать на какие компоненты можно разделить бизнес-логику
   и как ее делить. Это не декомпозиционная задача. Мы моделируем поведение конечными
   автоматами, где есть состояния и переходы между ними. Нельзя это дальше как-то
   делить, вопрос поставлен неверно. Иногда декомпозиция - не лучший метод справиться
   со сложностью.

** Слой =HardwarePresentationLayer=

   =HardwarePresentationLayer= - это нижний слой архитектуры на котором конкретное
   оборудование преобразуется в абстрактное представление для =BusinessLogicLayer=. Это
   то как для бизнес-логики выглядят конкретные устройства.

*** Компонент =HardwareDisplayComponent=

    =HardwareDisplayComponent= - это компонент, отвечающий за отображение конкретных
    данных на разные типы конкретных дисплеев. Т.е. мы отсылаем на дисплей сообщение в
    =DisplayPresentationComponent=, а этот уровень определяет как это будет отображено.

    =DisplayPresentationComponent= - это компонент, представляющий абстрактное описание
    информации, должной быть отраженной на дисплее. При каждом обновлении компонент
    передает изменения в описании в =HardwareDisplayComponent=.

    [TODO:santi ranma unrimah] Обсудить озвученный ниже вопрос по PresentationComponent
    =UIPresentationComponent= - это компонент представления тех частей оборудования,
    которые являются интерфейсом пользователя.

    =LogicPresentationComponent= - это компонент представления тех частей оборудования,
    которые связаны с бизнес-логикой.

    [COMMENT:ranma] Cуществуют данные, которые являются одновременно и интерфейсом
    пользователя и данными/событиями для бизнес-логики. Какой компонент будет отвечать
    за представление таких данных?  Например, событие "чек на въезд распечатан"
    относится только к бизнеслогике.

    А событие "нажата кнопка выдачи чека на въезд" относится одновременно и к UI и к
    бизнес-логике. Но это искусственное разделение.  На самом деле нет разницы между
    событием от UI и событием - следствием автоматического процесса.

    Таким образом я считаю, что разделение на UI и Logic не требуется и достаточно
    сделать один компонент, вот такой: =DevicePresentationComponent= - это компонент,
    содержащий абстрактное представление всех конкретных устройств, включая элементы
    UI. Он отвечает за прием данных от =HWDeviceComponent= и от =BusinessLogicLayer=
    и за преобразование принятых данных в абстрактное представление из реального и обратно.

    =HWDeviceComponent= - это компонент, отвечающий за работу непосредственно с
    подключенным оборудованием.  Он производит прием и передачу данных через
    =CommunicationComponent=. Он записывает в оборудование настройки из
    =HardwareSettingComponent=. Прием и передача производятся посредством проприетарных
    протоколов.

    [TODO:pyub] составить приоритетность разработки протоколов под конкретное
    оборудование

    =CommunicationComponent= - это компонент, отвечающий за работу с коммуникационным
    оборудованием: UARTs, sockets, etc.  Он настраивает оборудование согласно
    настройкам из =CommunicationSettingComponent= для настроек, относящихся только к
    локальному коммуникационному оборудованию и из =HardwareSettingComponent= для
    настроек, относящихся к корректному обмену с подключенным оборудованием.  Например:
    Размер системных буферов для UART это вопрос =CommunicationSettingComponent=, а
    вопрос скорости обмена с оборудованием - =HardwareSettingComponent=.

** Слой =DriverLayer=

   Это аппаратно-зависимые компоненты - драйвера конкретных устройств, устанавливаемые,
   как модули ядра. Большинство модулей уже имеется в ядре Linux, как-то GPIO,
   коммуникациционный стек, etc.
   Драйверы могут понадобиться для редких дисплеев, некоторых RTC и иной периферии.

   =DisplayComponent= - драйвер дисплея.

** Обособленный слой =SettingLayer=

*** Компонент =CommunicationSettingComponent=

    =CommunicationSettingComponent= - это компонент, оперирующий всеми настройками
    коммуникационного оборудования для работы с контроллером. Например, скорость работы
    с COM-портом для общения конкретного устройства с контроллером.

*** Компонент =HardwareSettingComponent=

    =HardwareSettingComponent= - это компонент, оперирующий конкретными командамми
    настроек оборудования (например, скорость печати принтера). По сути на это уровень
    диспетчиризации между BL и железом по протоколу предоставленному разработчиком.

*** Компонент =BusinessLogicSettingComponent=

    =BusinessLogicSettingComponent= - настройки бизнес-логики, т.е. работы системы в
    зависисмости от различных условий.

*** Компонент =SoftwareSettingComponent=

    =SoftwareSettingComponent= - настройка функционирования ПО (например, логирование,
    настройки пользователей и ролей), находящиеся в неком хранилище (базе данных).

*** Компонент =NotificationComponent=

    =NotificationComponent= - оповещает все архитектурные слои о произошедшем изменении
    настроек.

** Слой =UILayer=

   =UILayer= - это уровень описывающий пользовательские интерфейсы удаленного доступа .

   =SWUIcomponent= это различные операторские и администраторские web-интерйесы
   серверов и контроллеров (ПО управления парковкой) и

   =HWUIComponent= это интерфейсы собственно стоек для посетителей- дисплеи с текстом и кнопки
   клавиатуры.

* Что на чём пишем

  =BL= - LISP [rigidus]

  =SW= - PostgreSQL & LISP [rigidus], PostgreSQL & C++ [ranma].

  Чисто движком БД мы здесь не обойдемся, так как требуются оповещения об изменении
  настроек.

  =HW,COM= - C++,boost [ranma,unrimah]

  =KernelModules= - C [ranma,unrimah]

* Требования к функционалу =HardwarePresentationLayer=
** Получение данных и формирование событий

   Получение данных от датчиков и оборудования и формирование по ним событий для уровня
   =BusinessLogicLayer= по определенным правилам.

   Организация внутренних таймеров для выработки событий в случаях недостатка датчиков,
   согласно ТЗ.

** Асинхронная работа с оборудованием по вызовам от =BusinessLogicLayer=

   Асинхронная работа с конкретным оборудованием парковки подразумевает возможность
   подать команду, запросить состояние или получить событие от оборудования независимо
   от текущей работы по с другим оборудованием, если только это оборудование не
   разделяет физические ресурсы с тем, с которым в текущий момент нужно вести работу.

   [TODO:ranma] "Поведение при занятости физического ресурса" - ты говоришь о занятом
   порте или сокете?
   [COMMENT:ranma] Речь о любом ресурсе, который разделяется между более чем одним внешним устройством.
   Да, в тч сокет, порт, пин etc

** Cписок конкретного оборудования, которое должно поддерживаться

   В списке абстрактного оборудования (на данный момент он только абстрактный) будут
   вложенями даны ссылки на конкретное оборудование: [[file:doc.org::*%d0%9f%d0%b5%d1%80%d0%b8%d1%84%d0%b5%d1%80%d0%b8%d0%b9%d0%bd%d0%be%d0%b5%20%d0%be%d0%b1%d0%be%d1%80%d1%83%d0%b4%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5][периферийное оборудование]] (в
   doc.org)

   Полное раскрытие списка оборудования, сенсоров и кнопок: [[file:doc.org::*%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D0%B5%D1%80%D0%B8%D1%84%D0%B5%D1%80%D0%B8%D0%B8%20%D0%BA%20%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D1%83][Подключение периферии к
   контроллеру]] (в doc.org) В графе "Тип устройства" описан абстрактный тип, в графе
   "Предполагаемая модель" конкретная модель, в графе "Интерфейс подключения" -
   собственно интерфейс.

   [COMMENT:pyub] До описания протоколов обмена данными мы пока не дошли. Это задача
   [TODO:unrimah].

*** Протокол обмена с картоприемником

    Структуры данных, ссылка.

*** Управление и контроль шлагбаума

    Команды и события, ссылка.

*** Управление и контроль термопринтера

    Структуры данных, ссылка.

*** Список используемых датчиков

    Уровни логических сигналов для состояний.  [[file:doc.org::*%D0%92%D0%B2%D0%BE%D0%B4%D1%8B%20%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D0%BE%D0%B2%20%D1%81%20%D0%B4%D0%B0%D1%82%D1%87%D0%B8%D0%BA%D0%BE%D0%B2][Вводы сигналов с датчиков]]

*** Список кнопок

    Уровни логических сигналов для состояний.

    [[file:doc.org::*%D0%92%D0%B2%D0%BE%D0%B4%D1%8B%20%D1%81%20%D0%BA%D0%BD%D0%BE%D0%BF%D0%BE%D0%BA][Вводы с кнопок]]

** Асинхронная работа с коммуникационным оборудованием

   =Асинхронная работа= - это работа с каналом связи без блокировки этого канала при
   передаче по нему данных.

теы с любым каналом связи без
   необходимости блокировки как остальных каналов, так и текущего активного канала

 с коммуникационным оборудованием подразумевает возможность
   приема/передачи данных независимо от текущей работы по с другим коммуникационным
   оборудованием.

   Список каналов:
   - communication ports
   - IO pins
   - usb
   - ethernet (tcp/ipv4)

*** Список оборудования, подключаемого к =CommunicationComponent=

    Оборудование, подключаемое к =CommunicationComponent=

*** Список датчиков, подключаемых к =CommunicationComponent=

    Оборудование, подключаемое к =GPIO= - датчики 'сухой контакт'.

*** Список реле, подключаемых к =CommunicationComponent=

    Оборудование, подключаемое к =GPIO= - управление типа 'реле'.

*** Список оборудование, подключаемого к usb

    Оборудование, подключаемое к =usb=.

*** Ethernet

    Cвязь с сервером по =ethernet=: =сеансовый уровень=.

    [comment:pyub] связь контроллера с контроллером по =ethernet=?
    [REPLY:ranma] какого контроллера с каким контроллером?

** Преобразование данных между конкретным и абстрактным представлениями

   [COMMENT:pyub] Правильно ли я понимаю, что абстрактное представление это, например,
   "сигнал датчика арбитража", а конкретное представление - это "12В с реле =R7= стойки
   выигравшей арбитраж на сенсорный ввод =S4= стойки проигравшей арбитраж"?
   [REPLY:ranma] Да.

   Список оборудования (на данный момент абстрактный): [[file:doc.org::*%d0%9f%d0%b5%d1%80%d0%b8%d1%84%d0%b5%d1%80%d0%b8%d0%b9%d0%bd%d0%be%d0%b5%20%d0%be%d0%b1%d0%be%d1%80%d1%83%d0%b4%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5][периферийное оборудование]] (в
   doc.org) Полное раскрытие списка с сенсорами и кнопками:
   [[file:doc.org::*%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D0%B5%D1%80%D0%B8%D1%84%D0%B5%D1%80%D0%B8%D0%B8%20%D0%BA%20%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D1%83][Подключение
   периферии к контроллеру]] (в doc.org)

   [TODO:ranma] Пример подобного описания событий в существующем doc.org можешь
   привести?

*** События, команды и структуры данных абстрактного картоприемника
*** События, команды и структуры данных абстрактного шлагбаума
*** События, команды и структуры данных абстрактного термопринтера
*** События, команды и структуры данных абстрактного датчика
*** События, команды и структуры данных абстрактной кнопки

** Чтение настроек оборудования от уровня хранение и обновления

   Чтение настроек для каждого конкретного оборудования от уровня хранения и обновления
   настроек =SettingsLayer=.

   [TODO] Описание и ссылка

** Структура линейных алгоритмов от =BusinessLogicLayer= до практической реализации

   [COMMENT:unrimah] Во-первых, структура может иерархической, а не линеной, алгоритмы
   и переходы могут быть не линейными. Во-вторых, суть описания данной структуры вижу в
   том, что помочь нам работать так, чтобы все технические задачи являлись прямыми
   подзазадчими бизнес-логики.
   [REPLY:ranma] Все было понято совсем не так. Это про другое. Объясню позже.

   Организация линейных алгоритмов работы оборудования для абстрагирования их до одной
   команды и одного события для =BuisnessLogicLayer=.

* Требования к реализации =HardwarePresentationLayer=

** Интерфейс обмена с уровнем =BusinessLogicLayer=

   1.1 Связь уровней в пилотной версии обеспечивается через протокол TCP/IPv4 на
   localhost.  Порт по выбору разработчика.

   [COMMENT:ranma] Кто сервер, а кто клиент - надо обсудить.

   1.2 Формат данных при обмене должен удовлетворять требованиям к JSON document.

   1.3 В продакшн версии обсуждается использование FFI - foreign function interface.

   1.4 Формат команды в JSON от =BusinessLogicLayer= к HWVirtualizeLayer: {
   deviceName:<device name>[, command:<command type>, data:<data structure>] }

   1.5 Формат команды в JSON от =HardwarePresentationLayer= к BusinessLogicLayer: {
   deviceName:<device name>[, event:<event type>, data:<data structure>] } event type
   может быть в том числе и запросом данных от BusinessLogicLayer.

** Интерфейс настройки оборудования

   Интерфейс к настройкам оборудования должен быть предоставлен уровнем хранения и
   обновления настроек =SettingsLayer=.

** Интерфейс к коммутационному оборудованию

   Интерфейс к коммуникационному оборудованию предоставляется операционной системой и
   используемым фреймворком.

   Каждому типу коммуникационного оборудования должен соответствовать шаблонный
   синглтон. Каждому конкретному оборудованию - синглтон-инстанс с заданным параметром:
   номер оборудования этого типа.

** Интерфейс к подключённому оборудованию

   Интерфейс к подключенному оборудованию должен быть описан в документации к
   конкретному оборудованию. TODO: Список протоколов, подлежащих реализации.

   Каждому типу оборудования должен соответствовать шаблонный синглтон. Каждому
   конкретному оборудованию - синглтон-инстанс с заданным параметром: номер
   оборудования этого типа.

** Стандарт доступа к ресурсам ядра

   При разработке =HWVirtualizeLayer= на языке С++ необходимо использовать единый
   стандарт доступа к ресурсам ядра с помощью определенного стандартного
   фреймворка. Использование других возможностей ОС и других фреймворков по умолчанию
   запрещено, опционально оговаривается отдельно.

   Выбор стандарта и фреймворка исходя из требований полной модульности и
   кроссплатформенности среди *nix-совместимых ОС.

   Выбор проводился между:

   =POSIX= + =STL only= - всем известны, долго писать, плодить лишние уровни
   архитектуры) - неэффективно

   =STL= + =boost= (boost на старте требует некоторого уровня входа, можно быстро и
   легко создавать многопоточный безопасный код, может полностью заменить POSIX, код
   получается полностью кроссплатформенный, код долго собирается) - эффективно

   =QT= (требует отдельных навыков разработки, не удовлетворяет требованиям полной
   модульности) - не подходит для этой задачи

   [COMMENT:ranma] Предлагаю использовать C++ + STL + boost.

   [TODO] Доводы против писать здесь.



* Требования к тестированию.

**  Модули, требующие отдельных тестов.

   1.1 универсальный шаблон сериализатора / десериализатора 1.2

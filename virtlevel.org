+HTML_HEAD: <!-- -*- fill-column: 87 -*- -->
#+HTML_HEAD: <!-- org-toggle-inline-images -->

#+TITLE: Virtlevel
#+INFOJS_OPT: view:overview toc:nil

#+TAGS: { pyub ranma rigidus unrimah noa}

#+NAME:css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="/css/css.css" />
#+END_HTML

Архитектура системы, уровни алгоритмов работы с оборудованием

* Описание и цели

  Этот файл описывает интерфейс нижнего архитектурного уровня
  =HWVirtualizeLayer=, предназначенного для виртуализации
  оборудования. Этот архитектурный уровень выполняет функцию
  преобразования логики работы различных вариантов подключенного
  конкретного оборудования ([TODO:ranma] Эта логика - это какие уровни
  собственно?) в единообразный интерфейс абстрактного оборудования
  =BusinessLogicLayer=.

  Цели:
  - предоставить уровню бизнес-логики =BusinessLogicLayer=
    единообразный интерфейс работы с любым набором оборудования
  - взять на себя работу с параметрами конкретного подключенного
    оборудования.

* Сущности и уровни архитектуры

  [TODO:ranma] Проверь, пожалуйста, моё понимание сущностей

  =hardware= - всё, что связано с оборудованнием

  =software= - всё, что связано с исполняемым ПО

  =UI= (user interface) - всё, что связано с интерфейсом пользователя

  =Presentation= - представление конкретного оборудования в памяти в
  виде структур данных и событий.


** Слой =BusinessLogicLayer=

   =BusinessLogicLayer= - это абстрактный слой описания процессов для
   абстрактного функционального оборудования.

** Слой =HardwarePresentationLayer=

   =HardwarePresentationLayer= - это нижний слой архитектуры на
   котором конкретное оборудование преобразуется в абстрактное
   представление для =BusinessLogicLayer=. Это то как для
   бизнес-логики выглядят конкретные устройства.

*** Компонент =HardwareDisplayComponent=

    =HardwareDisplayComponent= - это слой отображения конкретных данных на разные
    типы конкретных дисплеев. Т.е. мы отсылаем на дисплей сообщение, в
    уровень определяет как это будет отображено.

** Слой =DriverLayer=

   ???

** Обособленный слой =SettingLayer=

*** Компонент =CommutationSettingsLayer=

    =CommutationSettingsLayer= - это слой оперирующий всеми настройками
    коммуникационного оборудования для работы с контроллером. Например,
    скорость работы с COM-портом для общения конкретного устройства с
    контроллером.

    [TODO:pyub] составить приоритетность разработки протоколов под
    конкретное оборудование

*** Компонент =HardwareSettingLayer=

    =HardwareSettingLayer= - слой оперирующий конкретными командамми настроек оборудования
    (например, скорость печати принтера). По сути на это уровень
    диспетчиризации между BL и железом по протоколу предоставленному разработчиком.

*** Компонент =BusinessLogicSettingLayer=

    =BusinessLogicSettingLayer= - настройки бизнес-логики, т.е. работы
    системы в зависисмости от различных условий.

*** Компонент =SoftwareSettingLayer=

    =SoftwareSettingLayer= - настройка функционирования ПО (например,
    логирование, настройки пользователей и ролей), находящиеся в неком
    хранилище (базе данных).

** Слой =UILayer=

  =UILayer= - это уровень описывающий пользовательский интерфейс.

  =SWUILayer=

  это различные операторские и администраторские web-интерйесы серверов и
  контроллеров (ПО управления парковкой) и

  =HWUIlayer=

  это интерфейсы собственно стоек для посетителей- дисплеи с текстом и
  кнопки клавиатуры.



* Что на чём пишем

  =BL= - LISP [rigidus]
  =SW= - PostgreSQL [rigidus]
  =HW= - С/C++ [ranma]
  =COM=

* Требования к функционалу =HWVirtualizeLayer=
** Получение данных и формирование событий

   Получение данных от датчиков и оборудования и формирование по
   ним событий для уровня =BusinessLogicLayer= по определенным правилам.

   Организация внутренних таймеров для выработки событий в случаях
   недостатка датчиков, согласно ТЗ.

** Асинхронная работа с оборудованием по вызовам от =BusinessLogicLayer=

   Асинхронная работа с конкретным оборудованием парковки
   подразумевает возможность подать команду, запросить состояние или
   получить событие от оборудования независимо от текущей работы по с
   другим оборудованием, если только это оборудование не разделяет
   физические ресурсы с тем, с которым в текущий момент нужно вести
   работу.

   [TODO:ranma] "Поведение при занятости физического ресурса" - ты гвооришь о
   занятом порте или сокете?

** Cписок конкретного оборудования, которое должно поддерживаться

   В списке абстрактного оборудования (на данный момент он только
   абстрактный) будут вложенями даны ссылки на конкретное оборудование:
   [[file:doc.org::*%d0%9f%d0%b5%d1%80%d0%b8%d1%84%d0%b5%d1%80%d0%b8%d0%b9%d0%bd%d0%be%d0%b5%20%d0%be%d0%b1%d0%be%d1%80%d1%83%d0%b4%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5][периферийное оборудование]] (в doc.org)

   Полное раскрытие списка оборудования, сенсоров и кнопок:
   [[file:doc.org::*%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D0%B5%D1%80%D0%B8%D1%84%D0%B5%D1%80%D0%B8%D0%B8%20%D0%BA%20%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D1%83][Подключение периферии к контроллеру]] (в doc.org) В графе "Тип
   устройства" описан абстрактный тип, в графе "Предполагаемая модель"
   конкретная модель, в графе "Интерфейс подключения" - собственно
   интерфейс.

   [COMMENT:pyub] До описания протоколов обмена данными мы пока не
   дошли. Это задача [TODO:unrimah].

*** Протокол обмена с картоприемником

    Структуры данных, ссылка.

*** Управление и контроль шлагбаума

    Команды и события, ссылка.

*** Управление и контроль термопринтера

    Структуры данных, ссылка.

*** Список используемых датчиков

    Уровни логических сигналов для состояний.
    [[file:doc.org::*%D0%92%D0%B2%D0%BE%D0%B4%D1%8B%20%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D0%BE%D0%B2%20%D1%81%20%D0%B4%D0%B0%D1%82%D1%87%D0%B8%D0%BA%D0%BE%D0%B2][Вводы сигналов с датчиков]]

*** Список кнопок

    Уровни логических сигналов для состояний.
    [[file:doc.org::*%D0%92%D0%B2%D0%BE%D0%B4%D1%8B%20%D1%81%20%D0%BA%D0%BD%D0%BE%D0%BF%D0%BE%D0%BA][Вводы с кнопок]]

** Асинхронная работа с коммуникационным оборудованием

   Асинхронная работа с коммуникационным оборудованием подразумевает
   возможность приема/передачи данных независимо от текущей работы по с
   другим коммуникационным оборудованием.

   Список каналов:
   - communication ports
   - IO pins
   - usb
   - ethernet (tcp/ipv4)

   =Канал индикатора= [TODO] надо ли индикатор выводить на этот
   уровень, если он всегда будет одинаковый? или для него делаем
   отдельный =HWindicatorLayer= в дополнение к =UILayer=?

   [TODO:ranma] Что такое канал индикаторов?

*** Список оборудование, подключаемого к COM

   Оборудование, подключаемое к =communication ports=
   [todo:unrimah] ссылки на протоколы обмен
   [todo:ranma] это rs-232 и rs-485?

*** Список оборудования, подключаемого на вводы сенсоров

   Оборудование, подключаемое к =input pins= -  датчики 'сухой контакт'.

*** Список оборудования, подключемого на выводы реле

   Оборудование, подключаемое к =output pins= - управление типа 'реле'.

*** Список оборудование, подключаемого к usb

   Оборудование, подключаемое к =usb=.

*** Ethernet

   Cвязь с сервером по =ethernet=: =сеансовый уровень=.

   [comment:pyub] связь контроллера с контроллером по =ethernet=?

** Преобразование данных между конкретным и абстрактным представлениями

   [COMMENT:pyub] Правильно ли я понимаю, что абстрактное
   представление это, например, "сигнал датчика арбитража", а
   конкретное представление - это "12В с реле =R7= стойки выигравшей
   арбитраж на сенсорный ввод =S4= стойки проигравшей арбитраж"?

   Список оборудования (на данный момент абстрактный):
   [[file:doc.org::*%d0%9f%d0%b5%d1%80%d0%b8%d1%84%d0%b5%d1%80%d0%b8%d0%b9%d0%bd%d0%be%d0%b5%20%d0%be%d0%b1%d0%be%d1%80%d1%83%d0%b4%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5][периферийное оборудование]] (в doc.org)
   Полное раскрытие списка с сенсорами и кнопками:
   [[file:doc.org::*%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D0%B5%D1%80%D0%B8%D1%84%D0%B5%D1%80%D0%B8%D0%B8%20%D0%BA%20%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D1%83][Подключение периферии к контроллеру]] (в doc.org)

   [TODO:ranma] Пример подобного описания событий в существующем
   doc.org можешь привести?

*** События, команды и структуры данных абстрактного картоприемника
*** События, команды и структуры данных абстрактного шлагбаума
*** События, команды и структуры данных абстрактного термопринтера
*** События, команды и структуры данных абстрактного датчика
*** События, команды и структуры данных абстрактной кнопки

** Чтение настроек оборудования от уровня хранение и обновления

   Чтение настроек для каждого конкретного оборудования от уровня
   хранения и обновления настроек =SettingsLayer=.

   [TODO] Описание и ссылка

** Структура линейных алгоритмов от =BuisnessLogicLayer= до практической реализации

   [COMMENT:unrimah] Во-первых, структура может иерархической, а не
   линеной, алгоритмы и переходы могут быть не линейными. Во-вторых,
   суть описания данной струкутры вижу в том, что помочь на работать
   так, чтобы се технические задачи являлись прямыми подзазадчими
   бизнес-логики.

   Организация линейных алгоритмов работы оборудования для
   абстрагирования их до одной команды и одного события для
   =BuisnessLogicLayer=.

   [TODO:ranma] Уже не актуально, строка поменялась, давай конкретику
   (примеры: строка 969, строка 1015 в doc.org)

* Требования к реализации =HWVirtualizeLayer=

** Интерфейс обмена с уровнем =BusinessLogicLayer=

   1.1 Связь уровней в пилотной версии обеспечивается через протокол
   TCP/IPv4 на localhost.  Порт по выбору разработчика.

   [COMMENT:ranma] Кто сервер, а кто клиент - надо обсудить.

   1.2 Формат данных при обмене должен удовлетворять требованиям к
   JSON document.

   1.3 В продакшн версии обсуждается использование FFI - foreign
   function interface.

   1.4 Формат команды в JSON от =BusinessLogicLayer= к
   HWVirtualizeLayer: { deviceName:<device name>[, command:<command
   type>, data:<data structure>] }

   1.5 Формат команды в JSON от =HWVirtualizeLayer= к
   BusinessLogicLayer: { deviceName:<device name>[, event:<event
   type>, data:<data structure>] } event type может быть в том числе и
   запросом данных от BusinessLogicLayer.

** Интерфейс настройки оборудования

   Интерфейс к настройкам оборудования должен быть предоставлен
   уровнем хранения и обновления настроек =SettingsLayer=.

** Интерфейс к коммутационному оборудованию

   Интерфейс к коммуникационному оборудованию предоставляется
   операционной системой и используемым фреймворком.

   Каждому типу коммуникационного оборудования должен
   соответствовать шаблонный синглтон. Каждому конкретному
   оборудованию - синглтон-инстанс с заданным параметром: номер
   оборудования этого типа.

** Интерфейс к подключённому оборудованию

  Интерфейс к подключенному оборудованию должен быть описан в
  документации к конкретному оборудованию. TODO: Список протоколов,
  подлежащих реализации.

  Каждому типу оборудования должен соответствовать шаблонный
  синглтон. Каждому конкретному оборудованию - синглтон-инстанс с
  заданным параметром: номер оборудования этого типа.

** Стандарт доступа к ресурсам ядра

   При разработке =HWVirtualizeLayer= на языке С++ необходимо
   использовать единый стандарт доступа к ресурсам ядра с помощью
   определенного стандартного фреймворка. Использование других
   возможностей ОС и других фреймворков по умолчанию запрещено,
   опционально оговаривается отдельно.

   Выбор стандарта и фреймворка исходя из требований полной модульности
   и кроссплатформенности среди *nix-совместимых ОС.

   Выбор проводился между:

   =POSIX= + =STL only= - всем известны, долго писать, плодить лишние
   уровни архитектуры) - неэффективно

   =STL= + =boost= (boost на старте требует некоторого уровня входа,
   можно быстро и легко создавать многопоточный безопасный код, может
   полностью заменить POSIX, код получается полностью
   кроссплатформенный, код долго собирается) - эффективно

   =QT= (требует отдельных навыков разработки, не удовлетворяет
   требованиям полной модульности) - не подходит для этой задачи

   [COMMENT:ranma] Предлагаю использовать C++ + STL + boost.

   [TODO] Доводы против писать здесь.

* Требования к тестированию.

**  Модули, требующие отдельных тестов.

1.1 универсальный шаблон сериализатора / десериализатора
1.2

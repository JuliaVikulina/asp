Интерфейс уровня виртуализации оборудования HWVirtualizeLayer.

Этот файл описывает интерфейс нижнего архитектурного слоя, предназначенного для виртуализации оборудования.
Этот архитектурный слой выполняет функцию преобразования логики работы различных вариантов подключенного конкретного оборудования в единообразный интерфейс абстрактного оборудования.
Цели:
- предоставить уровню бизнес-логики (BusinessLogicLayer) единообразный интерфейс работы с любым набором оборудования.
- взять на себя работу с параметрами конкретного подключенного оборудования.

Требования к функционалу HWVirtualizeLayer.
1. Получение данные от датчиков и оборудования и формирование по ним событий для уровня бизнес-логики по определенным правилам.
1.1 Организация внутренних таймеров для выработки событий в случаях недостатка датчиков, согласно ТЗ.
2. Отправление данных и команд на оборудование по вызовам от BusinessLogicLayer.
3. Асинхронная работа с коммуникационным оборудованием.
3.1 Список каналов: Communication ports, IO pins, USB?, Ethernet(TCP/IPv4)
3.2 Оборудование, подключаемое к Communication ports (ссылки на протоколы обмена): 
3.3 Оборудование, подключаемое к Input pins (датчики 'сухой контакт'):
3.4 Оборудование, подключаемое к Output pins (управление типа 'реле'):
3.5 Оборудование, подключаемое к USB: ?
3.6 Канал индикатора: TODO: надо ли индикатор выводить на этот уровень, если он всегда будет одинаковый? Или для него делаем отдельный HWIndicatorLayer в дополнение к UILayer?
3.7 Связь с сервером по Ethernet: сеансовый уровень.
4. Асинхронная работа с оборудованием по интерфейсу.
4.1 Список оборудования: абстрактный картоприемник, абстрактный шлагбаум, абстрактный термопринтер с датчиками, абстрактные датчики, абстрактная кнопка
4.2 События, команды и структуры данных абстрактного картоприемника:
4.3 События, команды и структуры данных абстрактного шлагбаума:
4.4 События, команды и структуры данных абстрактного термопринтера:
4.5 События, команды и структуры данных абстрактного датчика:
4.6 События, команды и структуры данных абстрактной кнопки:
5. Чтение настроек для каждого конкретного оборудования от уровня хранения и обновления настроек ( SettingsLayer TODO: описание ссылка)
6. опц. Организация линейных алгоритмов работы оборудования для абстрагирования их до одной команды и одного события для BusinessLogicLayer, примеры: строка 969, строка 1015 (doc.org)

Требования к реализации HWVirtualizeLayer.
1. Интерфейс обмена с уровнем BusinessLogicLayer.
1.1 Связь уровней в пилотной версии обеспечивается через протокол TCP/IPv4 на localhost. Порт по выбору разработчика. TODO: Кто сервер, а кто клиент - надо обсудить.
1.2 Формат данных при обмене должен удовлетворять требованиям к JSON document.
1.3 В продакшн версии обсуждается использование FFI - foreign function interface.
1.4 Формат команды в JSON от BusinessLogicLayer к HWVirtualizeLayer: { deviceName:<device name>[, command:<command type>, data:<data structure>] }
1.5 Формат команды в JSON от HWVirtualizeLayer к BusinessLogicLayer: { deviceName:<device name>[, event:<event type>, data:<data structure>] }
event type может быть в том числе и запросом данных от BusinessLogicLayer.
2. Интерфейс к настройкам оборудования должен быть предоставлен уровнем хранения и обновления настроек (SettingsLayer).
3. Интерфейс к коммуникационному оборудованию предоставляется операционной системой и используемым фреймворком.
3.1 Каждому типу коммуникационного оборудования должен соответствовать шаблонный синглтон. Каждому конкретному оборудованию - синглтон-инстанс с заданным параметром: номер оборудования этого типа.
4. Интерфейс к подключенному оборудованию должен быть описан в документации к конкретному оборудованию. TODO: Список протоколов, подлежащих реализации.
4.1 Каждому типу оборудования должен соответствовать шаблонный синглтон. Каждому конкретному оборудованию - синглтон-инстанс с заданным параметром: номер оборудования этого типа.
5. При разработке HWVirtualizeLayer на языке С++ необходимо использовать единый стандарт доступа к ресурсам ядра с помощью определенного стандартного фреймворка. Использование других возможностей ОС и других фреймворков по умолчанию запрещено, опционально оговаривается отдельно.
5.1 Выбор стандарта и фреймворка исходя из требований полной модульности и кроссплатформенности среди *nix-совместимых ОС.
Выбор проводился между: 
- POSIX+STL only (всем известны, долго писать, плодить лишние уровни архитектуры) - неэффективно
- STL+boost (boost на старте требует некоторого уровня входа, можно быстро и легко создавать многопоточный безопасный код, может полностью заменить POSIX, код получается полностью кроссплатформенный, код долго собирается) - эффективно
- QT (требует отдельных навыков разработки, не удовлетворяет требованиям полной модульности) - не подходит для этой задачи
5.2 Вывод: Предлагаю использовать C++ + STL + boost.
5.3 Доводы против писать здесь:

Требования к тестированию.
1. Модули, требующие отдельных тестов.
1.1 универсальный шаблон сериализатора / десериализатора
1.2 

